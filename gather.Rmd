---
title: "ADA Analysis"
author: "Monica Chang"
date: "9/25/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(gt)
library(readxl)
library(lubridate)
library(skimr)
library(janitor)
```


```{r clean 2018 and 2020 data}

# I filter the 2018 and 2020 data so that they have consistent columns.

ada_request_2018 <- read_excel("raw_data/2018_ADA_Requests.xlsx") %>%
  
  # Clean column names, drop unnecessary columns and correct one column name.
  
  clean_names() %>%
  select(-c("touch_point_name_111")) %>%
  rename(if_the_ada_request_occurred_in_the_ea_shelter_please_indicate_which_agency_3223 = if_the_ada_request_occurred_in_the_ea_shelter_please_indicate_w,
         name = ada_request_data_name) 
  

ada_request_2020 <- read_excel("raw_data/2020_ADA_Requests.xlsx") %>%
  
  # Clean column names, drop unnecessary columns and correct column order.
  
  clean_names() %>%
  
  # The 2020 data does not ask about hotels/motels or other accommodations, but
  # we add them here for consistency with 2018 data.
  
  mutate(if_the_ada_request_occurred_in_the_hotel_motel_please_indicate = NA) %>%
  mutate(if_other_ada_accomodation_requested_please_describe_3226 = NA) %>%
  select(participant_enterprise_identifier, 
         name,
         date_taken_111, 
         where_did_the_ada_request_occur_3211,
         if_the_ada_request_occurred_in_the_ea_shelter_please_indicate_which_agency_3223, 
         if_the_ada_request_occurred_in_the_hotel_motel_please_indicate,
         date_that_the_central_ada_coordinator_received_ada_request_3212,
         ada_accommodation_request_3213,
         if_other_ada_accomodation_requested_please_describe_3226,
         reason_for_the_ada_request_3214,
         if_other_reason_please_describe_3227,
         date_the_decision_made_3215,
         was_the_ada_request_approved_3216,
         if_partial_please_explain_3217,
         if_closed_please_explain_3219,
         was_the_accommodations_met_3218,
         how_was_the_accommodation_met_3221,
         date_the_accommodation_met_3220) 

# Takes in a ADA request tibble that has already been filtered to the 
# correct columns. This function renames columns, eliminates 
# hyphens from the pei, eliminates duplicate rows, and pivots the data 
# so that each row represents a unique accommodation request made (i.e.
# if someone requested 3 different accommodations on one day, they would
# appear as 3 different rows). This will allow me to manually go through and
# account for partial approvals.

clean_ada_request <- function(x) {
  x <- x %>%
    
    # Rename columns.
    
    rename(pei = participant_enterprise_identifier,
           date_received = date_that_the_central_ada_coordinator_received_ada_request_3212,
           date_decision = date_the_decision_made_3215,
           date_taken = date_taken_111,
           date_acc_met = date_the_accommodation_met_3220,
           req_where = where_did_the_ada_request_occur_3211,
           shelter_from = if_the_ada_request_occurred_in_the_ea_shelter_please_indicate_which_agency_3223,
           hotel_from = if_the_ada_request_occurred_in_the_hotel_motel_please_indicate,
           acc_type = ada_accommodation_request_3213,
           other_acc_type = if_other_ada_accomodation_requested_please_describe_3226,
           request_reason = reason_for_the_ada_request_3214,
           other_request_reason = if_other_reason_please_describe_3227,
           approved = was_the_ada_request_approved_3216,
           partial = if_partial_please_explain_3217,
           closed = if_closed_please_explain_3219,
           acc_met = was_the_accommodations_met_3218,
           how_acc_met = how_was_the_accommodation_met_3221) %>%
    
    # Eliminate hyphens from the PEI identification number.
    
    mutate(pei = gsub("-", "", pei)) %>%
    
    # Eliminate duplicate rows.
    
    distinct() %>%
    
    # No more than 4 accommodations are provided to any one row. So, I divide the
    # request column into five columns, based on the "\\|" divider. Missing 
    # values are filled on the right.
    
    separate(acc_type, into = c("a", "b", "c", "d", "e"), sep = "\\|", fill = 'right') %>%
    
    # I want to collapse these four columns into "tidy" format, where each row
    # represents a unique request made. So, I pivot the data to make it longer.
    
    pivot_longer(cols = c(a, b, c, d, e), 
                 names_to = "letter_id",  
                 values_to = "request_type") %>%
    
    # If any of the columns c(a, b, c, d, e) were empty before I pivoted longer, 
    # an "NA" value will appear. Additionally, I notice that some cells seem to
    # just contain an empty space (likely due to data entry errors). So, I drop
    # the NAs and remove the cells that are just empty spaces.
    
    drop_na(request_type) %>%
    filter(request_type != "") %>%
    
    # I rename certain accommodation request types to ensure that 2018 and
    # 2020 data follow similar conventions.
    
    mutate(request_type = recode(request_type, 
                                 `Comfort Animal within Placement Unit` = "Assistance Animal within Placement Unit",
                                 `Scattered Site Placement Unit` = "Scattered Site Placement Unit / Co-housing Unit",
                                 `Placement Unit Close to Service Providers (when a participant is placed out of area away from their current medical providers)` = "Placement Unit Close to Service Providers",
                                 `Physical Modification to Placement Unit (visual cues for hearing impaired, grab bars in shower, etc.)` = "Physical Modification to Placement Unit")) %>%
  
    # I rename certain accommodation request reasons to ensure that 2018 and
    # 2020 data follow similar conventions.
    
    mutate_if(is.character, str_replace_all, pattern = "Developmental Disability / Behavioral", replacement = "Developmental Disability") %>%
    mutate_if(is.character, str_replace_all, pattern = "Developmental Disability", replacement = "Developmental Disability / Behavioral") %>%
    mutate_if(is.character, str_replace_all, pattern = "Mental / Emotional Health", replacement = "Mental Health") %>%
    
    # I separate request_reason into multiple columns to account for individuals
    # that requested accommodations for more than one reason.
    
    separate(request_reason, into = c("reason_1", "reason_2", "reason_3", "reason_4"), sep = "\\|", fill = 'right') %>%
    
    # I create a variable calculating the days it takes for each unique ADA
    # request to be met - based on the date_received and data_acc_met columns.

    mutate(days_until_accommodation_met = as.double(difftime(lubridate::ymd(date_acc_met),
                                                             lubridate::ymd(date_received),
                                                             units = "days"))) %>%
    
    # Re-order columns and drop unnecessary columns.
    
    select(pei, name, date_received, date_decision, date_taken, date_acc_met, 
           days_until_accommodation_met, request_type, reason_1:reason_4, 
           req_where:how_acc_met) 

  }

ada_request_2018 <- clean_ada_request(ada_request_2018)
ada_request_2020 <- clean_ada_request(ada_request_2020)

# Combine the 2018 and 2020 touchpoint data.

ada_request_2018_2020 <- bind_rows(ada_request_2018, ada_request_2020)
write_csv(ada_request_2018_2020, 
          path = "/Users/monicachang/Documents*/fall_2020/gov_50/project/Garcia-vs-DHCD/processed_data/ada_request_2018_2020_partials_unprocessed.csv")


```

```{r accounting for partial approvals and other categories}

# After doing the above data cleaning, I manually went through the data 
# to account for partial approvals that provided sufficient information to 
# determine whether a unique accommodation request was approved or not. 
# Note: 32 partial approvals did not provide sufficient information to 
# manually input approval data so they were not counted.

# I also manually went through the "other" categories for request type and 
# request reason to categorize frequently occurring answers (e.g. AC Unit,
# additional bedrooms).

col_types <- cols(
  .default = col_character(),
  date_received = col_datetime(format = ""),
  date_decision = col_datetime(format = ""),
  date_taken = col_datetime(format = ""),
  date_acc_met = col_datetime(format = ""),
  days_until_accommodation_met = col_double(),
  partial = col_character(),
  closed = col_logical()
)

# Filter the data to only count approved requests. I pivot my data so that
# each row represents one request i.e. each row is uniquely identified by 
# PEI + date_received. 2108/3638 requests are approved. We are assuming 
# that DHCD correctly approves requests.

# Note: 1847/2108 PEIs only show up once. Some individuals have submitted 
# multiple approved requests.

approved_adas <- read_csv(file = "/Users/monicachang/Documents*/fall_2020/gov_50/project/Garcia-vs-DHCD/processed_data/ada_request_2018_2020_partials_processed.csv", col_types = col_types) %>%
  filter(approved == "Yes") %>%
  mutate(dummy = 1) %>%
  
  # I pivot my data wider. The names of the columns in my wider table 
  # will be the values currently in the 'accommodation_request' column. 
  # The values in those columns will be either 0 if the category is not
  # relevant, or 1 if the category was requested in that case.
  
  pivot_wider(names_from = request_type, 
              values_from = dummy,
              names_prefix = "req_",
              values_fill = 0) %>%
  clean_names() %>%
  
  # I similarly pivot my data for request reasons.
  
  pivot_longer(cols = reason_1:reason_4, 
               names_to = "reason_id", 
               values_to = "request_reason", 
               values_drop_na = TRUE) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = pei:req_physical_modification_to_placement_unit, 
              names_from = request_reason, 
              values_from = dummy, 
              names_prefix = "reason_",
              values_fill = 0) %>%
  clean_names() %>%
  
  # I specify the column order that I want.
  
  select(pei:hotel_from, acc_met, how_acc_met,
         req_placement_unit_close_to_service_providers,
         req_scattered_site_placement_unit_co_housing_unit,
         req_other,
         req_first_floor_or_elevator_access,
         req_assistance_animal_within_placement_unit,
         req_non_carpeted_placement_unit,
         req_physical_modification_to_placement_unit,
         req_access_to_full_cooking_facilities,
         req_ac_unit,
         req_wheelchair_accessible_placement_unit,
         req_change_in_ea_regulation_re_housing_plan,
         req_additional_bedrooms,
         req_assigned_caretaker_temporary_non_ea_household_member,
         reason_physical_health:reason_other)

# Save this tibble as a compressed RDS file to be used in the Shiny app.

saveRDS(approved_adas, file = "shiny/data/approved_adas.rds")

```


```{r approved ADA request tables and plots}

approved_requests <- approved_adas %>%
  pivot_longer(cols = req_placement_unit_close_to_service_providers:req_assigned_caretaker_temporary_non_ea_household_member, 
               names_to = "accommodation_type", 
               values_to = "requests") %>%
  group_by(accommodation_type) %>%
  summarize(total_requests = sum(requests), .groups = "drop") %>%
  arrange(desc(total_requests)) %>%
  mutate(pct_requests = total_requests/sum(total_requests))

# Create a table showing the requests by accommodation type.

approved_requests %>%
  gt() %>%
  tab_header(
    title = "Percentage of approved ADA requests by accommodation type",
    subtitle = glue::glue("2015 to 2019")
  ) %>%
  fmt_passthrough(
    columns = vars(accommodation_type, total_requests)
  ) %>%
  fmt_percent(
    columns = vars(pct_requests)
  )

# Create a plot showing the requests by accommodation type.

approved_requests %>%
  ggplot(aes(x = pct_requests, y = fct_reorder(accommodation_type, pct_requests))) +
    geom_col() +
    theme_bw() +
    scale_y_discrete(labels = c("Caretaker", "Additional bedrooms", "Change in regulation/re-housing plan", "Wheelchair", "AC Unit", "Cooking facilities", "Physical modification", "Non-carpeted", "Assistance animal", "First floor/elevator",  "Other", "Scattered site/Co-housing", "Service providers")) +
    labs(title = "Percentage of approved ADA requests \nby accommodation type (2015-2019)",
         subtitle = "Proximity to service providers and scattered site housing \nwere by far the most frequently requested accommodations.",
         x = "Percentage of approved requests", 
         y = "Accommodation type",
         caption = "Source: Department of Housing & Community Development")

approved_reasons <- approved_adas %>%
  pivot_longer(cols = reason_physical_health:reason_other, 
               names_to = "reason_type", 
               values_to = "requests") %>%
  group_by(reason_type) %>%
  summarize(total_requests = sum(requests), .groups = "drop") %>%
  arrange(desc(total_requests)) %>%
  mutate(pct_requests = total_requests/sum(total_requests))

# Create a table showing the requests by reason type.

approved_reasons %>%
  gt() %>%
  tab_header(
    title = "Percentage of approved ADA requests by reason type",
    subtitle = glue::glue("2015 to 2019")
  ) %>%
  fmt_passthrough(
    columns = vars(reason_type, total_requests)
  ) %>%
  fmt_percent(
    columns = vars(pct_requests)
  )

# Create a plot showing the requests by reason type.

approved_reasons %>%
  ggplot(aes(x = pct_requests, y = fct_reorder(reason_type, pct_requests))) +
    geom_col() +
    theme_linedraw() +
    scale_y_discrete(labels = c("Other", "Developmental/ \nbehavioral disability", "Emotional health", "Mental health", "Physical health")) +
    labs(title = "Percentage of approved ADA requests \nby reason type (2015-2019)",
         x = "Percentage of approved requests", 
         y = "Reason type",
         caption = "Source: Department of Housing & Community Development")

```


```{r approved ADA request time plot}

# Create a plot showing the proportion of approved ADA requests met over time.

# Note: 52 requests have a negative # of days_until_accommodation_met which 
# doesn't make sense. This analysis excludes these requests. This plot is  
# based on the 572 approved requests that have a positive # of 
# days_until_accommodation_met. 

# Note: 1484/2108 (70%) of the date_acc_met values are missing! 
# We will need transfer/bed registry data to supplement these missing values.
         
approved_adas %>%
  filter(days_until_accommodation_met >= 0) %>% 
  group_by(days_until_accommodation_met) %>%
  summarize(num_requests_met = n(), .groups = "drop") %>%
  mutate(prop_requests_met = num_requests_met/nrow(approved_adas)) %>%
  mutate(cum_prop_requests = cumsum(prop_requests_met)) %>%
  ggplot(aes(x = days_until_accommodation_met, y = cum_prop_requests)) +
    geom_line() + 
    xlim(0, 100) +
    ylim(0, 1) +
    labs(title = "Proportion of approved ADA requests that were met (2015-2019)", 
         x = "Days until accommodation was met",
         y = "Proportion of requests met")
```


```{r clean bed registry data}

# I clean the data on shelter characteristics to select relevant columns. 
# This tibble provides information on whether each location meets certain 
# unit_type accommodations (scattered site, bedrooms, first floor, elevator,
# visual/hearing impairment, AC, carpeting, wheelchair accessible).

# Note: This information cannot address hotel placements or the following types
# of accommodations: 
# req_placement_unit_close_to_service_providers (1201), 
# req_other (212)
# req_assistance_animal_within_placement_unit (151) 
# req_access_to_full_cooking_facilities (42)
# req_change_in_ea_regulation_re_housing_plan (27)
# req_assigned_caretaker_temporary_non_ea_household_member (5) 

shelter_characteristics <- read_excel("raw_data/DHCD6_126075.xlsx") %>%
  clean_names() %>% 
  
  # I replace the values in the accommodation columns to display 1 when the
  # accommodation exists and 0 when the accommodation does not exist.
  
  mutate_at(vars(visually_impaired:public_transportation_accessible), ~ifelse(. == "Yes", 1, 0)) %>%
  
  # I replace the values in the unit_type column to display 1 when the
  # unit type is either a scattered site or co-shelter site, a 2 when the site 
  # is a congregate shelter, and 0 when the unit_type information is not given.
  
  mutate_at(vars(unit_type), ~ifelse(. == "Scattered Sites" | . == 
                                       "Co-Shelter", 1, ifelse(. == "Congregate", 2, 0))) %>%
  mutate(ffloor_elevator = ifelse(floor == 1 | elevator == 1, 1, 0)) %>%
  mutate(phys_mod = ifelse(visually_impaired == 1 | hearing_impaired == 1, 1, 0)) %>%
  mutate(non_carpeted = ifelse(carpeting == 1, 0, 1)) %>%
  select(name, site, program_name, city, zip_code, unit_type, bedrooms, floor, visually_impaired:public_transportation_accessible, ffloor_elevator, phys_mod, non_carpeted)
  
```



```{r clean transfer data}

# I clean and merge the data on internal transfers (transfers within a program 
# e.g. from Heading Home Congregate Shelter to a Heading Home Scattered Site) 
# and external transfers (transfers from one site to another e.g. from Heading 
# Home to JRI) by renaming appropriate columns, pivoting the data longer, 
# and row binding.

external_transfers <- read_excel("raw_data/combined_Referrals_EA_Placement_Unit.xlsx") %>%
  clean_names() %>%
  rename(pei = participant_enterprise_identifier,
         hotel_placement = site_to_program_name,
         non_hotel_placement = entity_to,
         date_referral = date_referral_was_accepted_or_rejected) %>%
  mutate(pei = gsub("-", "", pei)) %>%
  pivot_longer(cols = hotel_placement:non_hotel_placement, 
               names_to = "transfer_type_specific", 
               values_to = "transfer_location", 
               values_drop_na = TRUE) %>%
  mutate(transfer_type = "external") %>%
  select(pei, transfer_type, transfer_type_specific, transfer_location, date_referral) %>%
  arrange(date_referral) 
   
internal_transfers <- read_excel("raw_data/combined_EA_Providers_Internal_Transfers.xlsx") %>%
  clean_names() %>%
  rename(pei = participant_enterprise_identifier,
         date_referral = referral_date) %>%
  mutate(pei = gsub("-", "", pei)) %>%
  pivot_longer(cols = site_to:entity_to, 
               names_to = "transfer_type_specific", 
               values_to = "transfer_location", 
               values_drop_na = TRUE) %>%
  
  # I filter out all internal transfers to stabilization units.
  
  filter(str_detect(transfer_location, regex("Stabilization", ignore_case = TRUE)) == FALSE) %>%
  mutate(transfer_type = "internal") %>%
  select(pei, transfer_type, transfer_type_specific, transfer_location, date_referral) %>%
  arrange(date_referral) 

transfers <- bind_rows(external_transfers, internal_transfers) %>%
  arrange(date_referral)

saveRDS(transfers, file = "shiny/data/transfers.rds")

# I use a left_join because I want to keep all of the rows from my approved_adas
# tibble - even if there is no corresponding internal or external transfer. I 
# filter out cases where the date of referral is before the date the 
# ADA application was received - because those referrals are not relevant to
# address the disability request.

ada_transfers <- left_join(approved_adas, transfers, by = "pei") %>%
  filter(date_received < date_referral | is.na(date_referral) | is.na(date_received)) %>%
  distinct() %>%

# 87 approved requests have no date_received recorded.
# We will substitute date_received with the date_decision + the mean of the diff 
# between date_received and date_decision.

  mutate(days_btwn_decision_received = as.double(difftime(lubridate::ymd(date_decision),
                                                          lubridate::ymd(date_received),
                                                          units = "days"))) %>%
  mutate(mean_days_btwn_decision_received = mean(days_btwn_decision_received, na.rm = TRUE)) %>%
  mutate(date_received = if_else(is.na(date_received), 
                                 as.Date(date_decision) - mean_days_btwn_decision_received,
                                 as.Date(date_received))) %>%
  mutate(days_until_accommodation_met = as.double(difftime(lubridate::ymd(date_acc_met),
                                                           lubridate::ymd(date_received),
                                                           units = "days"))) %>%
  select(pei:date_received, date_decision:date_referral)

# Each individual can have multiple internal and external transfers as well as 
# multiple ADA requests. Since we have no certain way of knowing which transfer 
# met which ADA request - I will track whether the most recent request was met 
# at each transfer. We are assuming that once the individual's needs are met 
# once, the request was met. E.g. If request was met at transfer 5, that
# date_referral is the new date_acc_met.

# NOTE: This will be an undercount because someone could have repeated additive 
# requests.

# In the future, DHCD should include info on the temporary/permanent nature of 
# the need in their data collection. Mental health needs are probably not 
# temporary. We may want to do more specific analysis.

# TODO: Merge in bed registry characteristics to see whether each transfer meets someone's request. 
# I can only do this for placement unit requests (not service providers).
# Filter out requests that don't meet request.
# Use the date from that request as new date_acc_met.

ada_transfers_include_chars <-
  left_join(ada_transfers, shelter_characteristics, by = c("transfer_location" = "name")) %>% 
  
  # I coded placement_acc_met as 
  # - 2 if the individual did not request any unit type accommodations
  # - 1 if the individual had their unit type accommodations met
  # - 0 if the individual had their unit type accommodations not met
  # - NA if we had no characteristic info on the transfer location
  
  mutate(placement_acc_met = ifelse(req_scattered_site_placement_unit_co_housing_unit == 0 &
                                    req_first_floor_or_elevator_access == 0 &
                                    req_physical_modification_to_placement_unit == 0 &
                                    req_ac_unit == 0 &
                                    req_non_carpeted_placement_unit == 0 &
                                    req_wheelchair_accessible_placement_unit == 0, 
                             2, 
                             ifelse(req_scattered_site_placement_unit_co_housing_unit <= unit_type &
                                    req_first_floor_or_elevator_access <= ffloor_elevator &
                                    req_physical_modification_to_placement_unit <= phys_mod &
                                    req_ac_unit <= air_conditioning &
                                    req_non_carpeted_placement_unit <= non_carpeted &
                                    req_wheelchair_accessible_placement_unit <= wheelchair_accessible, 1, 0))) %>%
  select(pei:req_assigned_caretaker_temporary_non_ea_household_member, 
         transfer_type:non_carpeted, placement_acc_met)

ada_transfers_include_chars %>%
  group_by(transfer_type, transfer_type_specific) %>%
  summarize(num_requests = n())

# TODO:

# I can account for non_hotel placement (external) and entity_to (internal).
# program_to and hotel_placement aren't accounted for now.
#   - filter out program_to?
#   - determine what characteristics all hotels have (create assumption)
#   - look at legal standards for hotels/if chars exist somewhere

# non-placement accommodations aren't accounted for (filter out)

# filter to the correct transfer 
# for each pei-date combo,
# - if placement_acc_met = 1
# -   choose the earliest one that meets the need
# - if request was never met, set a 1-year censorship date for date_acc_met.

# TODO: Clean & merge HUD exit data. 

```

```{r generating misc spreadsheets as requested}

# Generate a spreadsheet of requests that include a service provider acc.

service_provider_requests <- approved_adas %>%
  filter(req_placement_unit_close_to_service_providers == 1) %>%
  select(pei:how_acc_met, reason_physical_health:reason_other) %>%
  arrange(desc(date_received)) %>%
  mutate(zipcode_of_provider = NA,
         distance_from_provider_required = NA,
         type_of_provider = NA,
         misc_notes = NA)

write_csv(service_provider_requests, 
                path = "/Users/monicachang/Documents*/fall_2020/gov_50/project/Garcia-vs-DHCD/processed_data/service_provider_requests.csv")

# Generate a spreadsheet of approved ADAs who have "NA" for date_received.

approved_adas_na_date <- approved_adas %>%
  filter(is.na(date_received))

write_csv(approved_adas_na_date, 
                path = "/Users/monicachang/Documents*/fall_2020/gov_50/project/Garcia-vs-DHCD/processed_data/approved_adas_na_date.csv")

# Generate a spreadsheet of people who underwent a ton of transfers (10+). 
# that may require follow-up for Laura.

ada_many_transfers <- ada_transfers %>%
  group_by(pei, name) %>%
  summarize(num_transfers = n(), .groups = "keep") %>%
  arrange(desc(num_transfers)) %>%
  filter(num_transfers > 5)

write_csv(ada_many_transfers, 
                path = "/Users/monicachang/Documents*/fall_2020/gov_50/project/Garcia-vs-DHCD/processed_data/approved_adas_many_tranfers.csv")
```

