---
title: "ADA Analysis"
author: "Monica Chang"
date: "9/25/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(gt)
library(readxl)
library(lubridate)
library(skimr)
library(janitor)
library(rsample)
library(rstanarm)
library(tidymodels)
library(ggmap)
library(leaflet)
library(tidyquant)
```


```{r accounting for partial approvals and other categories}

# After doing the above data cleaning, I manually went through the data 
# to account for partial approvals that provided sufficient information to 
# determine whether a unique accommodation request was approved or not. 
# Note: 32 partial approvals did not provide sufficient information to 
# manually input approval data so they were not counted.

# I also manually went through the "other" categories for request type and 
# request reason to categorize frequently occurring answers (e.g. AC Unit,
# additional bedrooms).

col_types <- cols(
  .default = col_character(),
  date_received = col_datetime(format = ""),
  date_decision = col_datetime(format = ""),
  date_taken = col_datetime(format = ""),
  date_acc_met = col_datetime(format = ""),
  days_until_accommodation_met = col_double(),
  partial = col_character(),
  closed = col_logical()
)

# I pivot my processed data so that each row represents one request 
# i.e. each row is uniquely identified by PEI + date_received.

all_adas <- read_csv(file = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_request_2018_2020_partials_processed.csv", col_types = col_types) %>%
  mutate(approved = ifelse(approved != "Yes" | is.na(approved), "No", approved)) %>%
  mutate(dummy = 1) %>%
  
  # I pivot my data wider. The names of the columns in my wider table 
  # will be the values currently in the 'accommodation_request' column. 
  # The values in those columns will be either 0 if the category is not
  # relevant, or 1 if the category was requested in that case.
  
  pivot_wider(names_from = request_type, 
              values_from = dummy,
              names_prefix = "req_",
              values_fill = 0) %>%
  clean_names() %>%
  
  # I similarly pivot my data for request reasons.
  
  pivot_longer(cols = reason_1:reason_4, 
               names_to = "reason_id", 
               values_to = "request_reason", 
               values_drop_na = TRUE) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = pei:req_wheelchair_accessible_placement_unit, 
              names_from = request_reason, 
              values_from = dummy, 
              names_prefix = "reason_",
              values_fill = 0) %>%
  clean_names() %>%
  mutate(date_received = as.character(date_received)) %>%
  mutate(date_received = as.POSIXct(date_received)) %>%
  
  # I create a variable to specify requests that contain unit type 
  # accommodations that are of interest. We are interested in requests 
  # for a service provider, scattered site, first floor, wheelchair accessible, 
  # or additional bedrooms since these are the only kinds of requests that 
  # cannot be met without a transfer. 
  
  # Unfortunately, we do not yet have provider zipcode information
  # to evaluate whether service provider requests were met. We also do not
  # have information about how many more bedrooms a location needs to
  # evaluate whether additional bedroom requests were met. For now, we 
  # exclude them from our analysis.
  
  mutate(interesting = ifelse(req_scattered_site_placement_unit_co_housing_unit == 1 |
                              req_first_floor_or_elevator_access == 1 |
                              req_wheelchair_accessible_placement_unit == 1, 1, 0)) %>%
  
  # I specify the column order that I want.
  
  select(pei:hotel_from, approved, acc_met, how_acc_met, interesting,
         req_placement_unit_close_to_service_providers,
         req_scattered_site_placement_unit_co_housing_unit,
         req_other,
         req_first_floor_or_elevator_access,
         req_assistance_animal_within_placement_unit,
         req_non_carpeted_placement_unit,
         req_physical_modification_to_placement_unit,
         req_access_to_full_cooking_facilities,
         req_ac_unit,
         req_wheelchair_accessible_placement_unit,
         req_change_in_ea_regulation_re_housing_plan,
         req_additional_bedrooms,
         req_assigned_caretaker_temporary_non_ea_household_member,
         reason_physical_health:reason_other)

boston_zips = c("02101", "02108", "02109", "02110", "02111", "02112", "02113", 
                "02114", "02115", "02116", "02117", "02118", "02119", "02120", 
                "02121", "02122", "02123", "02124", "02125", "02126", "02127", 
                "02128", "02129", "02130", "02131", "02132", "02133", "02134", 
                "02135", "02136", "02137", "02141", "02149", "02150", "02151",
                "02152", "02163", "02171", "02196", "02199", "02201", "02203", 
                "02204", "02205", "02206", "02210", "02211", "02212", "02215", 
                "02217", "02222", "02228", "02241", "02266", "02283", "02284", 
                "02293", "02297", "02298", "02445", "02467")

random_zips <- rep_sample_n(as_tibble(boston_zips), 1, replace = TRUE, reps = 2108)

# Only 57/1213 zipcodes of providers were provided. 
# 13 completely new individuals were added in. 44 individuals had their 
# zipcodes added in.

service_provider_zipcodes <- read_excel("processed_data/ADA_Geography.xlsx") %>%
  clean_names() %>%
  mutate_if(is.character, ~na_if(., "N/A")) %>%
  mutate_if(is.character, ~na_if(., "NA")) %>%
  rename(pei = pei_personal_enterprise_identifier) %>%
  mutate(date_received = as.Date(date_received)) %>%
  mutate(zipcode_of_provider = if_else(substr(zipcode_of_provider, 1, 1) == "/", 
                                       substr(zipcode_of_provider, 2, 6), 
                                       zipcode_of_provider)) %>%
  filter(!is.na(pei)) %>%
  select(pei, name, date_received, zipcode_of_provider:misc_notes)

# Filter the data to only count approved requests. 
# 2108/3638 requests are approved. We assume DHCD correctly approves requests.

# Note: 1847/2108 PEIs only show up once. Some individuals have submitted 
# multiple approved requests.

approved_adas_dates_fixed <- 
  left_join(all_adas, service_provider_zipcodes, by = c("pei", "name", "date_received")) %>%
  filter(approved == "Yes") %>%
  select(-approved) %>%
  
  # I change the date columns to be in date format to make them more 
  # understandable in my Shiny app.
  
  mutate(date_acc_met = as.Date(date_acc_met)) %>%
  mutate(date_received = as.Date(date_received)) %>%
  mutate(date_taken = as.Date(date_taken)) %>%
  mutate(date_decision = as.Date(date_decision))
  
# Save this tibble as a compressed RDS file to be used in the Shiny app.

saveRDS(approved_adas_dates_fixed, file = "shiny/data/approved_adas.rds")

```

```{r merge race with existing ADA dataset}

# Data go from 02-11-2011 to 01-09-2020

race_info <- read_excel("raw_data/20200408_Client_DHCD6_511242.xlsx") %>%
  clean_names() %>%
  rename(pei = personal_id) %>%
  
  # I eliminate rows where there is no race information for the client.
  # This brings us from 25,506 entries to 23,316 entries.
  
  filter(is.na(race_none)) %>%
  select(pei, dob, am_ind_ak_native:race_none, ethnicity:gender)

# 2,444/3,638 rows have race information.

adas_race <- left_join(all_adas, race_info, by = "pei") 

adas_race_2 <- adas_race %>%
  filter(!is.na(white)) %>%
  mutate(am_ind_ak_native = sum(am_ind_ak_native)) %>%
  mutate(asian = sum(asian)) %>%
  mutate(black_af_american = sum(black_af_american)) %>%
  mutate(native_hi_other_pacific = sum(native_hi_other_pacific)) %>%
  mutate(white = sum(white)) %>%
  select(am_ind_ak_native: white) %>%
  head(1) %>%
  pivot_longer(cols = am_ind_ak_native: white, 
               names_to = "race", 
               values_to = "num_requests", 
               values_drop_na = TRUE) 
  
ggplot(data = adas_race_2, mapping = aes(x = race, y = num_requests)) +
  geom_col() +
  labs(title = "Racial breakdown of ADA requests",
       subtitle = "32.82% of race values are missing.",
       x = "Race",
       y = "Number of ADA requests")

```


```{r approved ADA request tables and plots}

# I create a tibble of all requests by pivoting the tibble of all ADA
# requests longer and renaming the accommodations.

all_requests <- all_adas %>%
  pivot_longer(cols = req_placement_unit_close_to_service_providers:req_assigned_caretaker_temporary_non_ea_household_member, 
               names_to = "accommodation_type", 
               values_to = "requests") %>%
  mutate(accommodation_type = recode(accommodation_type, 
                                     req_placement_unit_close_to_service_providers = "Placement Unit Close to Service Providers",
                                     req_scattered_site_placement_unit_co_housing_unit = "Scattered Site Placement Unit / Co-housing Unit",
                                     req_assistance_animal_within_placement_unit = "Assistance Animal within Placement Unit",
                                     req_first_floor_or_elevator_access = "First Floor or Elevator Access",
                                     req_non_carpeted_placement_unit = "Non Carpeted Placement Unit",
                                     req_change_in_ea_regulation_re_housing_plan = "Change in EA Regulation / Re-Housing Plan",
                                     req_physical_modification_to_placement_unit = "Physical Modification to Placement Unit",
                                     req_access_to_full_cooking_facilities = "Access to Full Cooking Facilities",
                                     req_wheelchair_accessible_placement_unit = "Wheelchair Accessible Placement Unit",
                                     req_assigned_caretaker_temporary_non_ea_household_member = "Assigned Caretaker / Temporary Non-EA Household Member",
                                     req_additional_bedrooms = "Additional bedrooms",
                                     req_ac_unit = "AC Unit",
                                     req_other = "Other")) %>%
  group_by(accommodation_type) %>%
  summarize(total_requests = sum(requests), .groups = "drop") %>%
  arrange(desc(total_requests)) %>%
  mutate(percent = total_requests/sum(total_requests) * 100)

# I create a tibble of approved requests by pivoting the tibble of all 
# approved ADA requests longer and renaming the accommodations.

approved_requests <- approved_adas_dates_fixed %>%
  pivot_longer(cols = req_placement_unit_close_to_service_providers:req_assigned_caretaker_temporary_non_ea_household_member, 
               names_to = "accommodation_type", 
               values_to = "requests") %>%
  mutate(accommodation_type = recode(accommodation_type, 
                                     req_placement_unit_close_to_service_providers = "Placement Unit Close to Service Providers",
                                     req_scattered_site_placement_unit_co_housing_unit = "Scattered Site Placement Unit / Co-housing Unit",
                                     req_assistance_animal_within_placement_unit = "Assistance Animal within Placement Unit",
                                     req_first_floor_or_elevator_access = "First Floor or Elevator Access",
                                     req_non_carpeted_placement_unit = "Non Carpeted Placement Unit",
                                     req_change_in_ea_regulation_re_housing_plan = "Change in EA Regulation / Re-Housing Plan",
                                     req_physical_modification_to_placement_unit = "Physical Modification to Placement Unit",
                                     req_access_to_full_cooking_facilities = "Access to Full Cooking Facilities",
                                     req_wheelchair_accessible_placement_unit = "Wheelchair Accessible Placement Unit",
                                     req_assigned_caretaker_temporary_non_ea_household_member = "Assigned Caretaker / Temporary Non-EA Household Member",
                                     req_additional_bedrooms = "Additional bedrooms",
                                     req_ac_unit = "AC Unit",
                                     req_other = "Other")) %>%
  group_by(accommodation_type) %>%
  summarize(total_requests = sum(requests), .groups = "drop") %>%
  arrange(desc(total_requests)) %>%
  mutate(percent = total_requests/sum(total_requests) * 100) %>%
  mutate(percent = round(percent, 2))

saveRDS(approved_requests, file = "shiny/data/approved_requests.rds")

# I use a a left_join to create a merged tibble of all requests and 
# approved requests for each accommodation type.

requests <- left_join(all_requests, approved_requests, by = "accommodation_type") %>%
  rename(num_approved_requests = total_requests.y,
         num_all_requests = total_requests.x) %>%
  
  # I create a new column to calculate the percentage of requests that are
  # approved for each accommodation type.
  
  mutate(percent_approved = num_approved_requests/num_all_requests * 100) %>%
  mutate(percent_approved = round(percent_approved, 2)) %>%
  select(accommodation_type, num_approved_requests, num_all_requests, percent_approved) 

saveRDS(requests, file = "shiny/data/requests.rds")

# I create a plot that shows the number of requests approved and total for each
# accommodation type.

requests %>%
  pivot_longer(num_approved_requests:num_all_requests, names_to = "approved", values_to = "num_requests") %>%
  ggplot(aes(x = num_requests, y = fct_reorder(accommodation_type, num_requests), fill = approved)) +
    geom_col(position = "dodge") +
    theme_bw() +
    theme(legend.position = "bottom") +
    scale_fill_discrete(name = "Category", labels = c("All requests", "Approved requests")) +
    scale_y_discrete(labels = c("Caretaker", "Additional bedrooms", "Wheelchair", "AC Unit", "Cooking facilities", "Physical modification", "Change in regulation/re-housing plan", "Non-carpeted", "First floor/elevator", "Assistance animal",  "Other", "Scattered site/Co-housing", "Service providers")) +
    labs(title = "Number of requests by accommodation type \nand approval status (2015-2019)",
         subtitle = "Proximity to service providers and scattered site housing \nwere by far the most frequently requested accommodations.",
         x = "Number of requests", 
         y = "Accommodation type",
         caption = "Source: Department of Housing & Community Development")

# I create a plot showing approved requests by accommodation type.

approved_requests %>%
  ggplot(aes(x = percent, y = fct_reorder(accommodation_type, percent))) +
    geom_col() +
    theme_bw() +
    scale_y_discrete(labels = c("Caretaker", "Additional bedrooms", "Change in regulation/re-housing plan", "Wheelchair", "AC Unit", "Cooking facilities", "Physical modification", "Non-carpeted", "Assistance animal", "First floor/elevator",  "Other", "Scattered site/Co-housing", "Service providers")) +
    labs(title = "Percentage of approved ADA requests \nby accommodation type (2015-2019)",
         subtitle = "Proximity to service providers and scattered site housing \nwere by far the most frequently requested accommodations.",
         x = "Percentage of approved requests", 
         y = "Accommodation type",
         caption = "Source: Department of Housing & Community Development")

# I create a tibble of reasons for approved ADA requests by pivoting the 
# tibble of all approved ADA requests longer and renaming the reasons.

approved_reasons <- approved_adas_dates_fixed %>%
  pivot_longer(cols = reason_physical_health:reason_other, 
               names_to = "reason_type", 
               values_to = "requests") %>%
  mutate(reason_type = recode(reason_type, reason_mental_health = "Mental Health", 
                                           reason_emotional_health = "Emotional Health",
                                           reason_physical_health = "Physical Health",
                                           reason_developmental_disability_behavioral = "Developmental Disability/Behavioral Health",
                                           reason_other = "Other")) %>%
  group_by(reason_type) %>%
  summarize(total_requests = sum(requests), .groups = "drop") %>%
  arrange(desc(total_requests)) %>%
  mutate(percent = total_requests/sum(total_requests) * 100) %>%
  mutate(percent = round(percent, 2))

saveRDS(approved_reasons, file = "shiny/data/approved_reasons.rds")

# I create a plot showing approved requests by reason type.

approved_reasons %>%
  ggplot(aes(x = percent, y = fct_reorder(reason_type, percent))) +
    geom_col() +
    theme_linedraw() +
    scale_y_discrete(labels = c("Other", "Developmental/ \nbehavioral disability", "Emotional health", "Mental health", "Physical health")) +
    labs(title = "Percentage of approved ADA requests \nby reason type (2015-2019)",
         subtitle = "Physical health and mental health were the most common reasons for an ADA request.",
         x = "Percentage of approved requests", 
         y = "Reason type",
         caption = "Source: Department of Housing & Community Development")

```

```{r approved requests over time}

# I write a function that converts NaN to 0.

fix_nan <- function(x){
    x[is.nan(x)] <- 0
    x
}

# I create a tibble that contains the number of requests that were approved, 
# not approved, and the percentage approved for each accommodation type and month.

breakdown_by_time_acc <- adas_race %>%
  mutate(year = year(date_received)) %>%
  mutate(month = month(date_received)) %>% 
  
  # I can add this filter if I want to view these plots by accommodation type.
  
  # filter(req_placement_unit_close_to_service_providers == 1) %>%
  
  # I can add this filter if I want to view these plots by race.
  
  # filter(black_af_american == 1) %>%
  group_by(approved, year, month) %>%
  summarize(total_requests = n(), .groups = "drop") %>%
  pivot_wider(names_from = approved, values_from = total_requests) %>%
  mutate(date = make_date(year, month)) %>%
  clean_names() %>%
  mutate(total = yes + no) %>%
  mutate(percent = yes/(yes + no) * 100) %>%
  filter(!is.na(total))

# I create a plot showing the change in approval rate over time.

ggplot(breakdown_by_time_acc, aes(x = date, y = percent)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  ylim(0, 100) +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  scale_color_discrete(name = "Accommodation Type") +
  labs(title = "Change in ADA approval rate (2015-2019)",
       x = "Time (by month)",
       y = "Percentage of requests approved")

# I create a plot showing the change in total requests over time.

ggplot(breakdown_by_time_acc, aes(x = date)) + 
  geom_point(aes(y = total), color = "lightblue") +
  geom_point(aes(y = yes), color = "pink") +
  geom_smooth(aes(y = total), method = "loess", color = "blue") +
  geom_smooth(aes(y = yes), method = "loess", color = "red") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  scale_color_discrete(name = "Accommodation Type") +
  labs(title = "Change in number of ADA requests vs. \nchange in number of approved ADA requests (2015-2019)",
       subtitle = "Change in number of requests is shown in blue. \n Change in approved requests is shown in red.",
       x = "Time (by month)",
       y = "Number of requests")

# I create a plot showing the change in approved requests over time.

ggplot(breakdown_by_time_acc, aes(x = date, y = yes)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  ylim(0, 100) +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  scale_color_discrete(name = "Accommodation Type") +
  labs(title = "Change in number of approved requests (2015-2019)",
       x = "Month",
       y = "Number of approved requests")

```

```{r clean bed registry data}

# I clean the data on shelter characteristics to select relevant columns. 
# This tibble provides information on whether each location meets certain 
# unit_type accommodations (scattered site, bedrooms, first floor, elevator,
# visual/hearing impairment, AC, carpeting, wheelchair accessible).

# Externally, there are 156 hotel placements & 1692 non-hotel placements.
# Internally, there are 1295 entity_to transfers.
# 26 transfers are NA - there is no information on transfer_type provided.

# Note: This information cannot address hotel placements or the following types
# of accommodations: 
# req_placement_unit_close_to_service_providers (1201), 
# req_other (212)
# req_assistance_animal_within_placement_unit (151) 
# req_access_to_full_cooking_facilities (42)
# req_change_in_ea_regulation_re_housing_plan (27)
# req_assigned_caretaker_temporary_non_ea_household_member (5) 

shelter_characteristics <- read_excel("raw_data/DHCD6_126075.xlsx") %>%
  clean_names() %>% 
  
  # I replace the values in the accommodation columns to display 1 when the
  # accommodation exists and 0 when the accommodation does not exist.
  
  mutate_at(vars(visually_impaired:public_transportation_accessible), ~ifelse(. == "Yes", 1, 0)) %>%
  
  # I replace the values in the unit_type column to display 1 when the
  # unit type is either a scattered site or co-shelter site, a 2 when the site 
  # is a congregate shelter, and 0 when the unit_type information is not given.
  
  mutate_at(vars(unit_type), ~ifelse(. == "Scattered Sites" | . == 
                                       "Co-Shelter", 1, ifelse(. == "Congregate", 2, 0))) %>%
  mutate(ffloor_elevator = ifelse(floor == 1 | elevator == 1, 1, 0)) %>%
  mutate(phys_mod = ifelse(visually_impaired == 1 | hearing_impaired == 1, 1, 0)) %>%
  mutate(non_carpeted = ifelse(carpeting == 1, 0, 1)) %>%
  select(name, site, program_name, city, zip_code, unit_type, bedrooms, floor, visually_impaired:public_transportation_accessible, ffloor_elevator, phys_mod, non_carpeted)
  
```


```{r clean transfer data}

# I clean and merge the data on internal transfers (transfers within a program 
# e.g. from Heading Home Congregate Shelter to a Heading Home Scattered Site) 
# and external transfers (transfers from one site to another e.g. from Heading 
# Home to JRI) by renaming appropriate columns, pivoting the data longer, 
# and row binding.

external_transfers <- read_excel("raw_data/combined_Referrals_EA_Placement_Unit.xlsx",
           col_types = c("text", "text", "text", "text", "text", "text", "text", 
                         "text", "date", "text", "date", "text", "text")) %>%
  clean_names() %>%
  rename(pei = participant_enterprise_identifier,
         hotel_placement = site_to_program_name,
         non_hotel_placement = entity_to,
         date_referral = referral_date) %>%
  mutate(pei = gsub("-", "", pei)) %>%
  mutate(date_referral = ymd_hms(date_referral)) %>%
  pivot_longer(cols = hotel_placement:non_hotel_placement, 
               names_to = "transfer_type_specific", 
               values_to = "transfer_location", 
               values_drop_na = TRUE) %>%
  mutate(transfer_type = "external") %>%
  select(pei, transfer_type, transfer_type_specific, transfer_location, date_referral) %>%
  arrange(date_referral) %>%
  mutate(date_referral = ymd_hms(date_referral)) 
   
internal_transfers <- read_excel("raw_data/combined_EA_Providers_Internal_Transfers.xlsx",
                                 col_types = c("text", "text", "text", "text", 
                                               "text", "text", "text", "text", 
                                               "date", "text", "text", "text")) %>%
  clean_names() %>%
  rename(pei = participant_enterprise_identifier,
         date_referral = referral_date) %>%
  mutate(pei = gsub("-", "", pei)) %>%
  pivot_longer(cols = site_to:entity_to, 
               names_to = "transfer_type_specific", 
               values_to = "transfer_location", 
               values_drop_na = TRUE) %>%
  
  # I filter out all internal transfers to stabilization units.
  
  filter(str_detect(transfer_location, regex("Stabilization", ignore_case = TRUE)) == FALSE) %>%
  mutate(transfer_type = "internal") %>%
  select(pei, transfer_type, transfer_type_specific, transfer_location, date_referral) %>%
  arrange(date_referral) %>%
  mutate(date_referral = ymd_hms(date_referral)) 

transfers <- bind_rows(external_transfers, internal_transfers) %>%
  arrange(date_referral)

```


```{r merge adas and transfer}

# I use a left_join because I want to keep all of the rows from my approved_adas
# tibble - even if there is no corresponding internal or external transfer. 

ada_transfers <- left_join(approved_adas_dates_fixed, transfers, by = "pei") %>% 
  
  # I eliminate duplicate rows. 6502/7435 rows remain.
  
  distinct() %>% 
  
  # I am only able to analyze whether requests were met for scattered site,
  # first floor, and wheelchair accessible accommodations.
  # 2797/6502 rows remain.
  
  filter(interesting == 1) %>% 
  
  # 110 approved requests have no date_received recorded.
  # To impute these missing values, I calculate the the mean number of days 
  # between when an ADA request was received and when a decision was made. 

  mutate(days_btwn_decision_received = as.double(difftime(ymd(date_decision),
                                                          ymd(date_received),
                                                          units = "days"))) %>%
  mutate(mean_days_btwn_decision_received = round(mean(days_btwn_decision_received, 
                                                       na.rm = TRUE))) %>%
  
  # We will substitute NA date_received values with the date_decision +
  # the mean of the difference between date_received and date_decision.
  
  mutate(date_received = ifelse(is.na(date_received), 
                                date_decision - mean_days_btwn_decision_received,
                                date_received)) %>%
  
  mutate(date_received = as.Date(as.POSIXct(date_received*24*60*60, origin = "1970-01-01", tz="UTC"))) %>%

  # I filter out cases where the date of referral is before the date the 
  # ADA application was received - because those referrals are not relevant to
  # address the disability request. 1454/2797 rows remain.
  
  filter(date_received <= date_referral | is.na(date_referral) | is.na(date_received)) %>%
  select(pei:date_received, date_decision:date_referral)
```

```{r merge transfers and shelter characteristics}

# This function take in 3 arguments: 
# - a tibble formatted like ada_transfers
# - a tibble formatted like shelter_characteristics
# - a logical to indicate whether we assume a hotel successfully meets all 
#   unit type accommodations
# This function returns a merged tibble of transfers and shelter characteristics.

transfers_include_chars <- function(transfers, chars, hotel = TRUE) {
  
  # I use a left join because I want to keep all of the rows from my ada_transfers
  # tibble - even if there is no corresponding shelter characteristic information.
  # This merge will allow me to see whether the location the individual was 
  # transferred to meets that individual's disability accommodation request.
  
  left_join(transfers, chars, by = c("transfer_location" = "name")) %>% 
  
    # I coded unit_type_acc_met as 
    # - 1 if the individual had their unit type accommodations met
    # - 0 if the individual had their unit type accommodations not met
    # - NA if we had no characteristic info on the transfer location
    
    mutate(unit_type_acc_met = ifelse(req_scattered_site_placement_unit_co_housing_unit <= unit_type &
                                      req_first_floor_or_elevator_access <= ffloor_elevator &
                                      req_wheelchair_accessible_placement_unit <= wheelchair_accessible, 1, 0)) %>%
      
    # I am able to account for non_hotel placement and entity_to transfers
    # using my shelter characteristics dataset. Because I do not have information
    # on the characteristics of hotels, I will run a scenario where a hotel meets 
    # all unit type accommodations other than proximity to service providers 
    # and a scenario where a hotel doesn't meet any.
  
    mutate(unit_type_acc_met = ifelse(hotel == TRUE & transfer_type_specific == "hotel_placement", 1, 
                               ifelse(hotel == TRUE & transfer_type_specific != "hotel_placement", unit_type_acc_met,
                               ifelse(hotel == FALSE & transfer_type_specific == "hotel_placement", 0, 
                               ifelse(hotel == FALSE & transfer_type_specific != "hotel_placement", unit_type_acc_met, unit_type_acc_met))))) %>% 
                                     
    # In instances when a provider transfers a family from one of its programs to 
    # another, there is a two-step process. First, the provider refers the family 
    # to the new program. This will appear as a program_to transfer. Once the 
    # provider accepts the referral, the provider places the family in the new 
    # shelter unit. This appears as an entity_to transfer.
    
    # Since a program_to transfer is always followed by a more specific 
    # entity_to transfer, I can filter program_to transfers out.
    
    filter(transfer_type_specific != "program_to") %>%
    rename(zipcode_of_transfer = zip_code) %>%
    select(pei:date_taken, date_referral, date_acc_met, 
           days_until_accommodation_met, interesting, shelter_from, hotel_from,
           req_placement_unit_close_to_service_providers:transfer_location, 
           zipcode_of_transfer, unit_type_acc_met)
}

# FUTURE TODO: Look at which shelters are associated with the longest delays.

# Tibble generated when we make the assumption that a hotel transfer meets all
# unit type accommodations. 1223 observations.

transfers_chars_hotel_t <- transfers_include_chars(ada_transfers, shelter_characteristics, hotel = TRUE)

saveRDS(transfers_chars_hotel_t, file = "shiny/data/transfers_chars_hotel_t.rds")

# Tibble generated when we make the assumption that a hotel transfer meets no
# unit type accommodations. 1223 observations.

transfers_chars_hotel_f <- transfers_include_chars(ada_transfers, shelter_characteristics, hotel = FALSE)

saveRDS(transfers_chars_hotel_f, file = "shiny/data/transfers_chars_hotel_f.rds")
```


```{r merge hotel zips}

# I manually Googled hotel names to figure out the correct zipcodes.

hotel_locs <- transfers_chars_hotel_t %>% 
  filter(transfer_type_specific == "hotel_placement") %>% 
  select(transfer_location) %>% 
  distinct() %>%
  arrange(transfer_location) %>%
  mutate(zipcode_of_transfer = c("02135", "01906", "02135", "01040", 
                                 "02148", "02451","02188"))
  
  
# Correct zipcodes if service providers are included
# mutate(zipcode_of_transfer = c("02135", "02301", "02301", "01906", "01923", 
#                                 "02135", "01040", "01453", "02726", "01119",
#                                 "02703", "02777", "02148", "01040", "02451",
#                                 "02301", "02188"))

# Another intern went through transfer locations without zipcodes and used DHCD
# vacancy data and Google to deduce the correct zipcodes. Around 15% required
# some extra corroboration through Google.

caitlin_locs <- read_excel("processed_data/transfer_locations_with_zips.xlsx") %>%
  clean_names() %>%
  select(transfer_location, zip_code) %>%
  rename(zipcode_of_transfer = zip_code)

# Include hotel zipcodes.

transfers_chars_hotel_t_complete <- 
  left_join(transfers_chars_hotel_t, hotel_locs, by = "transfer_location") %>% 
  replace_na(list(zipcode_of_transfer.x = "", zipcode_of_transfer.y = "")) %>% 
  mutate(zipcode_of_transfer = if_else(zipcode_of_transfer.x != zipcode_of_transfer.y, 
                                  paste0(zipcode_of_transfer.x, zipcode_of_transfer.y),
                                  zipcode_of_transfer.x)) %>%
  select(-c(zipcode_of_transfer.x, zipcode_of_transfer.y)) %>%
  unique()

# Include Caitlin zipcodes. Only 4 out of 1227 rows are without zipcodes.

transfers_chars_hotel_t_complete_2 <- 
  left_join(transfers_chars_hotel_t_complete, caitlin_locs, by = "transfer_location") %>% 
  replace_na(list(zipcode_of_transfer.x = "", zipcode_of_transfer.y = "")) %>% 
  mutate(zipcode_of_transfer = if_else(zipcode_of_transfer.x != "",
                                       zipcode_of_transfer.x,
                                       if_else(zipcode_of_transfer.x == "" & zipcode_of_transfer.y != "",
                                               zipcode_of_transfer.y,
                                               ""))) %>%
  select(-c(zipcode_of_transfer.x, zipcode_of_transfer.y)) %>%
  mutate(zipcode_of_transfer = na_if(zipcode_of_transfer,"")) %>%
  unique()
  
```

```{r calculating distance/time between zipcodes}

btwn_zips <- transfers_chars_hotel_t_complete_2 %>%
  select(pei:date_received, zipcode_of_transfer, zipcode_of_provider) %>%
  mutate(zipcode_of_transfer = str_c(zipcode_of_transfer, ", USA")) %>%
  mutate(zipcode_of_provider = str_c(zipcode_of_provider, ", USA")) %>%
  filter(!is.na(zipcode_of_provider) & !is.na(zipcode_of_transfer)) %>%
  mutate(dist_btwn_zips = mapdist(zipcode_of_transfer, zipcode_of_provider) %>% select(miles)) %>%
  mutate(time_btwn_zips = mapdist(zipcode_of_transfer, zipcode_of_provider) %>% select(minutes)) %>%
  mutate(within_twenty = if_else(dist_btwn_zips < 20, 1, 0))
  
```


```{r clean ada transfers}

# Each individual can have multiple internal and external transfers as well as 
# multiple ADA requests. Since we have no certain way of knowing which transfer 
# met which ADA request - I will track whether the most recent request was met 
# at each transfer. We are assuming that once the individual's needs are met 
# once, the request was met. E.g. If request was met at transfer 5, that
# date_referral is the new date_acc_met.

# NOTE: This will be an undercount because someone could have repeated additive 
# requests.

# NOTE: In the future, DHCD should include info on the temporary/permanent 
# nature of the need in their data collection. Mental health needs are probably 
# not temporary. We may want to do more specific analysis on mental health.

# This function takes in a tibble generated by transfer_include_chars. It
# supplements the date_acc_met column with transfer data and filters the tibble
# to only retain one row for each pei-date combo.

supplement_date_acc_met <- function(df){
  df %>%
    
    # Group the data by each unique pei-date_received combo.
  
    group_by(pei, date_received) %>%
    
    # Keep the earliest transfer that meets the need OR
    # the earliest transfer that doesn't meet the need if the need is never met.
    
    arrange(desc(unit_type_acc_met), date_referral) %>%
    slice(1) %>%
    
    mutate(dhcd_data_exists = ifelse(!is.na(date_acc_met), 1, 0)) %>%
    mutate(days_btwn_dhcd_referral = as.double(difftime(date_acc_met,
                                                      date_referral,
                                                      units = "days"))) %>%
      
    # If a date_acc_met value already exists, we keep it. - ASK: YES OR NO?
    
    mutate(date_acc_met = ifelse(!is.na(date_acc_met), 
                                 date_acc_met, 
                                 
                                 # Else, if the request was met by the transfer, 
                                 # replace date_acc_met with date_referral.
                                 # If the request was never met, set a 1-year
                                 # censorship date.
                                 
                                 ifelse(unit_type_acc_met == 1, 
                                        as.Date(date_referral), 
                                        as.Date(date_received + 365)))) %>% 
    
    # I use strptime to convert my POSIXct object to an understandable datetime.
    
    mutate(date_acc_met = as.Date(as.POSIXct(date_acc_met*24*60*60, origin = "1970-01-01", tz="UTC"))) %>% 
    
    # I use format to make sure my dates follow the same conventions.
    
    mutate(date_received = as.Date(date_received)) %>%
    mutate(date_acc_met = as.Date(date_acc_met)) %>% 
    
    # I create a variable calculating the days it takes for each unique ADA
    # request to be met - based on the date_received and data_acc_met columns.
    
    mutate(days_until_accommodation_met = as.double(difftime(date_acc_met,
                                                             date_received,
                                                             units = "days")))
}

# For requests that ask for either scattered site, first floor, or wheelchair, 
# I substitute missing date_acc_met values with transfer information and assume 
# that hotel transfers meet all unit type accommodations. 609 rows.

supplemented_interesting_ada_transfers_t <- supplement_date_acc_met(transfers_chars_hotel_t) %>%
  filter(days_until_accommodation_met >= 0) 

saveRDS(supplemented_interesting_ada_transfers_t, 
        file = "shiny/data/supplemented_interesting_ada_transfers_t.rds")

# I filter the dataset to gauge how closely our substitution method matches 
# what is provided by DHCD. 74/136 are within 1 day of the date_acc_met value
# provided by the DHCD. 105/136 are within 1 week of the value provided by DHCD.

supplemented_interesting_ada_transfers_t %>%
  filter(unit_type_acc_met == 1) %>%
  filter(dhcd_data_exists == 1) %>%
  ggplot(aes(x = days_btwn_dhcd_referral)) + 
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100) +
    labs(title = "Distribution of the difference b/w provided DHCD values \n and values inferred based on substitution method",
           subtitle = "Substitutions are based on the most immediate referral after the request that met \n the unit-type disability accommodation (scattered site, wheelchair, first floor).",
           x = "Difference b/w provided DHCD values and inferred values (days)",
           y = "Probability")

# For requests that ask for either service provider, scattered site, 
# first floor, or wheelchair, I substitute all date_acc_met values with 
# transfer information and assume that hotel transfers don't meet all unit type 
# accommodations. 1204 rows.

supplemented_interesting_ada_transfers_f <- supplement_date_acc_met(transfers_chars_hotel_f) %>%
  filter(days_until_accommodation_met >= 0)

saveRDS(supplemented_interesting_ada_transfers_f, 
        file = "shiny/data/supplemented_interesting_ada_transfers_f.rds")

# FUTURE TODO: After we have a Kaplan-Meier plot that is more reliable, 
# we may be able to have a binary question (was this request met within 30 days)
# and identify a reasonable cut off date. Percentages are easier to understand.

# FUTURE TODO: Clean & merge HUD exit data. 

# FUTURE TODO: Is there demographic information for these individuals? 
# Do they only track for head of household or each individual?

```

```{r approved ADA request time plot}

# This function creates a Kaplan-Meier plot showing the percentage of 
# approved ADA requests met over time.
         
create_kaplan_meier <- function(df){
  df %>%
    filter(days_until_accommodation_met >= 0) %>% 
    group_by(days_until_accommodation_met) %>%
    summarize(num_requests_met = n(), .groups = "drop") %>%
    mutate(prop_requests_met = num_requests_met/nrow(df)) %>%
    mutate(cum_prop_requests = cumsum(prop_requests_met) * 100) %>%
    ggplot(aes(x = days_until_accommodation_met, y = cum_prop_requests)) +
      geom_line() + 
      xlim(0, 400) +
      ylim(0, 100) +
      labs(title = "Percentage of requests that were met (2015-2019)", 
           x = "Days until accommodation was met",
           y = "Percentage of requests met")
}

# This creates a Kaplan-Meier plot that takes into account ALL approved ADA 
# requests and only using the 2056 non-negative date_acc_met values provided by 
# DHCD.

# Note: 1484/2056 (70%) of the date_acc_met values are missing! 
# We will need transfer/bed registry data to supplement these missing values.

# Note: 52 requests have a negative # of days_until_accommodation_met which 
# doesn't make sense. This analysis excludes these requests. 

approved_adas_no_neg <- approved_adas_dates_fixed %>%
  filter(days_until_accommodation_met >= 0 | is.na(days_until_accommodation_met))

create_kaplan_meier(approved_adas_no_neg)

# This creates a Kaplan-Meier plot that takes into account requests that 
# ask for either scattered site, first floor, or wheelchair accessibility.
# This uses the 837 date_acc_met values provided by DHCD.

# Note: 676/837 (80%) of the date_acc_met values are missing! 
# We will need transfer/bed registry data to supplement these missing values.

interesting_approved_adas <- approved_adas_no_neg %>% 
  filter(interesting == 1) 

saveRDS(interesting_approved_adas, file = "shiny/data/interesting_approved_adas.rds")
  
create_kaplan_meier(interesting_approved_adas)

# This creates a Kaplan-Meier plot that ONLY takes into account requests that 
# ask for either scattered site, first floor, or wheelchair and substitutes 
# missing date_acc_met values with transfer information (606 requests). 
# The biggest unknown is whether service provider requests were met. 

create_kaplan_meier(supplemented_interesting_ada_transfers_t)
create_kaplan_meier(supplemented_interesting_ada_transfers_f)
```

$$ wait\_time_i = \beta_0 + \beta_1 reason_i + \beta_2 accommodation_i + \epsilon_i $$
```{r clean noncompliance data}
issued_nc <- read_excel("raw_data/20200408_Issued Noncompliance_DHCD6_511266.xlsx") %>%
  clean_names() %>%
  rename(pei = participant_enterprise_identifier,
         date_nc = date_of_incident,
         notice_type = type_of_notice_issued_2500,
         violation_type = what_type_of_violation_2712) %>%
  select(pei, date_nc, notice_type, violation_type) %>%
  
  # Eliminate hyphens from the PEI identification number.
    
  mutate(pei = gsub("-", "", pei)) %>%
  
  # No more than 3 violations are provided to any one row. So, I divide the
  # violation_type column into three columns, based on the "\\|" divider. 
  # Missing values are filled on the right.
    
  separate(violation_type, into = c("violation_1", "violation_2", "violation_3"), sep = "\\|", fill = 'right') %>%
  mutate(violation_1 = na_if(violation_1,""),
         violation_2 = na_if(violation_2,""),
         violation_3 = na_if(violation_3,""))

issued_nc %>%
  group_by(notice_type) %>%
  summarize(num_notices = n()) %>%
  arrange(desc(num_notices)) %>% View()

issued_nc %>%
  pivot_longer(cols = c(violation_1, violation_2, violation_3), 
               names_to = "violation",  
               values_to = "violation_type") %>%
  drop_na(violation_type) %>%
  filter(violation_type != "") %>%
  group_by(notice_type, violation_type) %>%
  summarize(num_violations = n()) %>%
  arrange(desc(num_violations)) %>% View()
```

```{r noncompliance model}
  
# I use a left join because I want to keep all of the rows from my 
# supplemented_interesting_ada_transfers_t tibble - even if there is no 
# corresponding non-compliance information.This merge will allow me to see 
# whether the individual received a non-compliance during their wait for
# disability accommodation.

# 105/609 individuals approved for scattered site, first floor, or wheelchair
# access were issued a non-compliance at any point.

# 105/609 individuals approved for scattered site, first floor, or wheelchair
# access were issued a non-compliance at any point.

# 72/105 of those individuals had a noncompliance after they applied for 
# disability accommodation.

# 6/72 of those individuals had a noncompliance after they applied for 
# disability accommodation AND before they received accommodation.

ada_ncs <- left_join(supplemented_interesting_ada_transfers_t, issued_nc, by = "pei") %>% 
  filter(date_nc >= date_received & date_nc <= date_acc_met) %>% 
  select(pei, name, date_received:days_until_accommodation_met, date_nc, dhcd_data_exists)

```

```{r model}

fit_obj <- stan_glm(days_until_accommodation_met ~ 
                      req_scattered_site_placement_unit_co_housing_unit,
                    data = supplemented_interesting_ada_transfers_t,
                    refresh = 0,
                    seed = 9)

print(fit_obj, digits = 4, detail = FALSE)

# I create a tibble to more easily extract the median values from stan_glm
# and graph the posterior distributions.

fit_obj_tbl <- as_tibble(fit_obj) %>%
  rename(mu = `(Intercept)`,
         predictor = req_scattered_site_placement_unit_co_housing_unit) %>%
  mutate(mu_median = median(mu)) %>%
  mutate(predictor_median = median(predictor))

# I create a tibble to extract the median values from stan_glm.

fit_obj_stats <- fit_obj_tbl %>%  
  select(mu_median, predictor_median) %>%
  slice(1)

fit_obj_stats

fit_obj_tbl %>% 
  
  # I add mu to the predictor column so that the posterior now
  # represents the average wait time for individuals without the 
  # specified predictor instead of the average change in wait time.
  
  mutate(predictor = predictor + mu) %>%
  pivot_longer(cols = mu:predictor,
               names_to = "parameter",
               values_to = "wait_time") %>%
  ggplot(aes(x = wait_time, fill = parameter)) +
    
    # I use overlapping histograms to display my two posterior distributions.
  
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    
    # I create a more descriptive legend title and labels.
  
    scale_fill_discrete(name = "Group", labels = c("Without Predictor", "With Predictor")) +
  
    # I add two dotted lines to more clearly show the median value for each 
    # posterior distribution.
  
    geom_vline(xintercept = fit_obj_stats$mu_median, 
               color = "red", 
               lty = "dashed") +
    geom_vline(xintercept = fit_obj_stats$predictor_median + fit_obj_stats$mu_median, 
               color = "blue", 
               lty = "dashed") +
    labs(title = "Posterior probability distributions",
         subtitle = "Predictive distributions of average wait time for individuals with and without the specified predictor",
         x = "Average number of days until accommodation met",
         y = "Probability")

# TODO: Add geom_density_ridges plot to show how the posteriors for different 
# types/reasons compare.

```

```{r generating misc spreadsheets as requested}

# Generate a spreadsheet of requests that include a service provider acc.

service_provider_requests <- approved_adas_dates_fixed %>%
  filter(req_placement_unit_close_to_service_providers == 1) %>%
  select(pei:how_acc_met, reason_physical_health:reason_other) %>%
  arrange(desc(date_received)) %>%
  mutate(zipcode_of_provider = NA,
         distance_from_provider_required = NA,
         type_of_provider = NA,
         misc_notes = NA)

write_csv(service_provider_requests, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/service_provider_requests.csv")

# Generate a spreadsheet of approved ADAs who have "NA" for date_received.

approved_adas_na_date <- approved_adas_dates_fixed %>%
  filter(is.na(date_received))

write_csv(approved_adas_na_date, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/approved_adas_na_date.csv")

# Generate a spreadsheet of people who underwent a ton of transfers (10+). 
# that may require follow-up for Laura.

ada_many_transfers <- ada_transfers %>%
  group_by(pei, name) %>%
  summarize(num_transfers = n(), .groups = "keep") %>%
  arrange(desc(num_transfers)) %>%
  filter(num_transfers > 5)

write_csv(ada_many_transfers, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/approved_adas_many_tranfers.csv")

# Generate a spreadsheet of people who have a ADA date_acc_met column filled out
# and require a transfer (service providers, scattered site, first floor, 
# wheelchair, bedrooms).

ada_date_acc_met_filled <- approved_adas_dates_fixed %>%
  filter(!is.na(date_acc_met)) %>%
  filter(req_placement_unit_close_to_service_providers == 1 |
         req_scattered_site_placement_unit_co_housing_unit == 1 |
         req_first_floor_or_elevator_access == 1 |
         req_wheelchair_accessible_placement_unit == 1 |
         req_additional_bedrooms == 1) %>%
  arrange(desc(date_received)) %>%
  select(pei, name)

ada_date_acc_met_filled_sample <- ada_date_acc_met_filled %>%
  sample_n(50) %>%
  select(pei, name)

write_csv(ada_date_acc_met_filled, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_date_acc_met_filled.csv")

write_csv(ada_date_acc_met_filled_sample, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_date_acc_met_filled_sample.csv")

# I repeat the above except also merge in the transfer data for these individuals.

ada_date_acc_met_filled_t <- 
  left_join(ada_date_acc_met_filled, transfers_chars_hotel_t, by = c("pei", "name")) %>%
  group_by(pei) %>%
  distinct(transfer_location, .keep_all = TRUE) %>%
  arrange(desc(date_received)) 

ada_date_acc_met_filled_sample_t <- 
  left_join(ada_date_acc_met_filled_sample, transfers_chars_hotel_t, by = c("pei", "name")) %>%
  group_by(pei) %>%
  distinct(transfer_location, .keep_all = TRUE) %>%
  arrange(desc(date_received)) 

write_csv(ada_date_acc_met_filled_t, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_date_acc_met_filled_t.csv")

write_csv(ada_date_acc_met_filled_sample_t, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_date_acc_met_filled_sample_t.csv")

# Generate a spreadsheet of date_approved, date of internal & external transfers
# for relevant PEIs for Dan.

ada_no_transfers <- read_excel("raw_data/ada_no_transfer.xlsx") %>%
  clean_names() %>%
  mutate(pei = gsub("-", "", pei))

ada_no_transfers_supplemented <- 
  left_join(ada_no_transfers, transfers_chars_hotel_t, by = c("pei", "name")) %>% 
  select(pei:days_until_accommodation_met, transfer_type:transfer_location) %>%
  group_by(pei) %>%
  distinct(transfer_location, .keep_all = TRUE)

write_csv(ada_no_transfers_supplemented, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/ada_no_transfers_supplemented.csv")

# Generate spreadsheet of transfer locations without zipcodes.

transfer_locations_without_zips <- transfers_chars_hotel_t %>%
  filter(str_length(zipcode_of_transfer) < 5) %>% 
  select(transfer_type, transfer_type_specific, transfer_location) %>%
  distinct() %>%
  arrange(transfer_type_specific, transfer_location)

write_csv(transfer_locations_without_zips, 
          path = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/processed_data/transfer_locations_without_zips.csv")

```

```{r interactive process analysis}

# I read in Erin's spreadsheet and select relevant columns to know when an 
# individual's application was received, whether they were engaged in an 
# interactive process, whether they received some form of response, and 
# whether they were accommodated.

erin_data <- "raw_data/erin_data.xls"
excel_sheets(path = erin_data)
active_portfolio <- read_excel(path = erin_data, sheet = "Complete Protfolio-ACTIVE") %>%
  clean_names() %>%
  mutate(name = paste(last_name, first_name, sep = ", ")) %>%
  select(name, date_received, date_ip_letter_sent, date_of_follow_up_contact, 
         date_additional_paperwork_received, date_of_final_decision, 
         partial_accommodation_add_1, full_accommodation_add_1) 

# I filter down the data to only include interactive process requests. 

ip <- active_portfolio %>%
  filter(!is.na(date_ip_letter_sent)) %>%
  mutate(year = year(date_received)) %>%
  mutate(month = month(date_received)) %>% 
  group_by(year, month) %>%
  summarize(total = n(), .groups = "drop") %>%
  mutate(date = make_date(year, month))

ggplot(ip, aes(x = date, y = total)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in number of interactive process requests",
       x = "Month",
       y = "Number of interactive process requests")

# I filter down the data to only include interactive process requests 
# that received some form of response.

ip_respond <- active_portfolio %>%
  filter(!is.na(date_ip_letter_sent)) %>%
  filter(!is.na(date_of_follow_up_contact) | 
         !is.na(date_additional_paperwork_received) |
         !is.na(date_of_final_decision)) %>%
  mutate(year = year(date_received)) %>%
  mutate(month = month(date_received)) %>% 
  group_by(year, month) %>%
  summarize(responded = n(), .groups = "drop") %>%
  mutate(date = make_date(year, month)) 

ggplot(ip_respond, aes(x = date, y = responded)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in number of interactive process requests that had either \n a follow-up contact, additional paperwork received, or a final decision made",
       x = "Month",
       y = "Number of interactive process requests")

# I filter down the data to only include interactive process requests 
# that received some form of response AND some form of accommodation.

ip_respond_acc <- active_portfolio %>%
  filter(!is.na(date_ip_letter_sent)) %>%
  filter(!is.na(date_of_follow_up_contact) | 
         !is.na(date_additional_paperwork_received) |
         !is.na(date_of_final_decision)) %>%
  filter(!is.na(partial_accommodation_add_1) | 
         !is.na(full_accommodation_add_1)) %>%
  mutate(year = year(date_received)) %>%
  mutate(month = month(date_received)) %>% 
  group_by(year, month) %>%
  summarize(accommodated = n(), .groups = "drop") %>%
  mutate(date = make_date(year, month)) 

ggplot(ip_respond_acc, aes(x = date, y = accommodated)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in number of interactive process requests that receive \nfollow-up and accommodation",
       subtitle = "A response can be either a follow-up contact, additional paperwork received, or final decision made.\nAn accommodation can be either partial or full accommodation.",
       x = "Month",
       y = "Number of interactive process requests")

# I create a tibble showing the percentage of IP requests that received 
# some form of response.

respond_rate <- left_join(ip, ip_respond, by = c("year", "month", "date")) %>%
  mutate(percent = responded/total * 100) %>%
  select(date, responded, total, percent)

ggplot(respond_rate, aes(x = date, y = percent)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  ylim(0, 100) +
  labs(title = "Change in percentage of interactive process requests that received a response",
       subtitle = "A response can be either a follow-up contact, additional paperwork received, or final decision made.",
       x = "Month",
       y = "% of IP requests that received a response")

# I create a tibble showing the percentage of IP requests that received 
# some form of response AND some form of accommodation.

accommodation_rate <- left_join(ip, ip_respond_acc, by = c("year", "month", "date")) %>%
  mutate(percent = accommodated/total * 100) %>%
  select(date, accommodated, total, percent)

ggplot(accommodation_rate, aes(x = date, y = percent)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  ylim(0, 100) +
  labs(title = "Change in percentage of interactive process requests that received accommodation",
       subtitle = "An accommodation can be either partial or full accommodation.",
       x = "Month",
       y = "% of IP requests that received accommodation")

accommodation_rate_2 <- left_join(ip_respond, ip_respond_acc, by = c("year", "month", "date")) %>%
  left_join(ip, by = c("year", "month", "date")) %>%
  mutate(percent_acc_resp = accommodated/responded * 100) %>%
  select(date, accommodated, responded, total, percent_acc_resp)

ggplot(accommodation_rate_2, aes(x = date)) + 
  geom_point(aes(y = responded), color = "pink") +
  geom_smooth(aes(y = responded), method = "loess", color = "red") +
  geom_point(aes(y = accommodated), color = "lightblue") +
  geom_smooth(aes(y = accommodated), method = "loess", color = "blue") +
  geom_point(aes(y = total), color = "lightgreen") +
  geom_smooth(aes(y = total), method = "loess", color = "green") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in number of interactive process requests over time",
       subtitle = "A response can be either a follow-up contact, additional paperwork received, or final decision made.\nAn accommodation can be either partial or full accommodation.",
       x = "Time (by month)",
       y = "Number of interactive process requests")


ggplot(accommodation_rate_2, aes(x = date, y = percent_acc_resp)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  ylim(0, 100) +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in percentage of interactive process requests w/ response \nthat received accommodation",
       subtitle = "An accommodation can be either partial or full accommodation.",
       x = "Month",
       y = "% of IP requests w/ response that received accommodation")
```
```{r vacancy analysis}

col_types <- cols(
  .default = col_character(),
  FAM = col_double(),
  BED = col_double(),
  TODD = col_double(),
  TWIN = col_double(),
  BUNK = col_double(),
  FULL = col_double(),
  TWINWTRUN = col_double(),
  BUNKWTRUN = col_double(),
  TYPE = col_logical(),
  RESPONSEID_109 = col_logical(),
  AUDITDATE_109 = col_logical(),
  DISABLED = col_logical(),
  LASTRESPONSE = col_logical(),
  ISACTIVE = col_logical(),
  REFERRALSTATUS = col_logical(),
  Date.Created = col_date(format = "")
)

# I pivot my processed data so that each row represents one request 
# i.e. each row is uniquely identified by PEI + date_received.

vacancies <- read_csv(file = "/Users/monicachang/Documents*/gbls/project/Garcia-vs-DHCD/raw_data/VacancyReports_DHCD.csv",
                      col_types = col_types)

# Note: 29.68% of type values are missing. 
# Note: Dates go from 12/21/2016 to 12/24/2019 for scattered site units. 
#       Dates go from 12/06/2016 to 12/24/2019 for the entire dataset.

vacancies_clean <- vacancies %>%
  clean_names() %>%
  
  # Went from 38913 entries to 4453 entries.
  
  filter(type == "Scattered Sites") %>%
  
  # Went from 4453 entries to 4358 entries. 
  
  filter(!is.na(date_created)) %>%
  
  # Find the number of scattered site vacancies per month from 12/21/2016 to 12/24/2019
  
  mutate(year = year(date_created)) %>%
  mutate(month = month(date_created)) %>% 
  group_by(year, month) %>%
  summarize(total = n(), .groups = "drop") %>%
  mutate(date = make_date(year, month))

ggplot(vacancies_clean, aes(x = date, y = total)) + 
  geom_point() +
  geom_smooth(method = "loess") +
  theme_linedraw() +
  coord_x_date(xlim = c("2015-10-01", "2020-11-01")) +
  labs(title = "Change in number of scattered site vacancies over time",
       subtitle = "This displays data for 12/21/2016 to 12/24/2019.",
       x = "Month",
       y = "Number of vacancies")


```